<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Development on Core Rule Set Documentation</title><link>https://coreruleset.github.io/documentation/development/</link><description>Recent content in Development on Core Rule Set Documentation</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://coreruleset.github.io/documentation/development/index.xml" rel="self" type="application/rss+xml"/><item><title>Contribution Guidelines</title><link>https://coreruleset.github.io/documentation/development/contribution_guidelines/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coreruleset.github.io/documentation/development/contribution_guidelines/</guid><description>The CRS project values third party contributions. To make the contribution process as easy as possible, a helpful set of contribution guidelines are in place which all contributors and developers are asked to adhere to.
Getting Started with a New Contribution Sign in to GitHub. Open a new issue for the contribution, assuming a similar issue doesn&amp;rsquo;t already exist. Clearly describe the issue, including steps to reproduce if reporting a bug.</description></item><item><title>regexp-assemble</title><link>https://coreruleset.github.io/documentation/development/regexp_assemble/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coreruleset.github.io/documentation/development/regexp_assemble/</guid><description>regexp-assemble is a toolset that helps the CRS developers to maintain the regular expressions in the rules. Its core functionality (owed to the great Regexp::Assemble Perl module) is to assemble individual parts of a regular expression into a single expression (with some optimizations), as this page explains.
Prerequisites A Perl environment and Perl version &amp;gt;= 5.10 A Python environment with Python version &amp;gt;= 3 Setup Initialize the Git submodule that contains the Regexp::Assemble Perl module by running:</description></item><item><title>Writing Rules</title><link>https://coreruleset.github.io/documentation/development/rule_writing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coreruleset.github.io/documentation/development/rule_writing/</guid><description>From years of experience, the CRS project has assembled a wealth of knowledge and advice on how to write clear and efficient WAF rules, as this page outlines.
The CRS project&amp;rsquo;s advice on rule writing is contained within the contribution guidelines, a document which can also be found in plain text form in CRS releases for offline reference. The guidelines contain invaluable guidance and tips on how to write rules, including:</description></item><item><title>Useful Tools</title><link>https://coreruleset.github.io/documentation/development/useful_tools/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coreruleset.github.io/documentation/development/useful_tools/</guid><description>There are many third party tools that help with ModSecurity and CRS development. The most useful ones are listed here. Get in touch if you think something is missing.
FTW https://pypi.org/project/ftw/
Framework for Testing WAFs. The original Python-based testing framework used by CRS.
Go-FTW https://github.com/fzipi/go-ftw
Framework for Testing WAFs in Go. A Go-based rewrite of the original Python FTW project. Usually much faster than the original and has no dependencies.</description></item><item><title>Testing the Rule Set</title><link>https://coreruleset.github.io/documentation/development/testing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coreruleset.github.io/documentation/development/testing/</guid><description>Testing for rule developers Well, you managed to write your rule, but now want to see if if can be added to the CRS? This document should help you to test it using the same tooling the project uses for its tests.
Tests are performed using a Python tool called ftw. We run them using a GitHub actions pipeline. You can easily reproduce that locally, in your workstation.
For that you will need:</description></item><item><title>Writing Plugins</title><link>https://coreruleset.github.io/documentation/development/plugin_writing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coreruleset.github.io/documentation/development/plugin_writing/</guid><description>The CRS plugin mechanism allows the rule set to be extended in specific, experimental, or unusual ways. This page explains how to write a new plugin to extend CRS.
How to Write a Plugin Is a Plugin the Right Approach for a Given Rule Problem? This is the first and most important question to ask.
CRS is a generic rule set. The rule set has no awareness of the particular setup it finds itself deployed in.</description></item><item><title>Using the CRS Sandbox</title><link>https://coreruleset.github.io/documentation/development/sandbox/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coreruleset.github.io/documentation/development/sandbox/</guid><description>Introducing the CRS Sandbox We have set up a public CRS Sandbox which you can use to send attacks at the CRS. You can choose between various WAF engines and CRS versions. The sandbox parses audit logs and returns our detections in an easy and useful format.
The sandbox is useful for:
integrators and administrators: you can test out our response in case of an urgent security event, such as the Log4j vulnerability; exploit developers/researchers: if you have devised a payload, you can test beforehand if it will be blocked by the CRS and by which versions; CRS developers/rule writers: you can quickly check if the CRS catches a (variant of an) exploit without the hassle of setting up your own CRS instance.</description></item></channel></rss>